//
//  Productions.swift
//  Covfefe
//
//  Created by Palle Klewitz on 07.08.17.
//  Copyright (c) 2017 Palle Klewitz
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.

import Foundation

/// A production describing what symbols can be generated starting from a given non-terminal pattern
public struct Production: Codable {
	
	/// Starting pattern
	public let pattern: NonTerminal
	
	/// Symbols produced from the starting pattern
	public let production: [Symbol]
	
	/// Chain of non-terminals which have been eliminated during normalization
	public let nonTerminalChain: [NonTerminal]?
	
	public let hashValue: Int
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(hashValue)
    }
	
	/// Creates a new production
	///
	/// - Parameters:
	///   - pattern: Starting pattern
	///   - production: Generated sequence of symbols
	public init(pattern: NonTerminal, production: ProductionString) {
		self.pattern = pattern
		self.production = production.characters
		self.nonTerminalChain = nil
		
		self.hashValue = pattern.hashValue ^ self.production.map{$0.hashValue}.reduce(0, ^)
	}
	
	/// Creates a new production
	///
	/// - Parameters:
	///   - pattern: Starting pattern
	///   - production: Generated sequence of symbols
	///   - chain: Non-terminals which have been filtered out during normalization
	public init(pattern: NonTerminal, production: [Symbol], chain: [NonTerminal]? = nil) {
		self.pattern = pattern
		self.production = production
		self.nonTerminalChain = chain
		
		self.hashValue = pattern.hashValue ^ production.map{$0.hashValue}.reduce(0, ^)
	}
	
	/// A production is final if it only generates terminal symbols
	public var isFinal: Bool {
        return self.production.allSatisfy { symbol -> Bool in
			if case .terminal(_) = symbol {
				return true
			} else {
				return false
			}
		}
	}
	
	/// A production is in Chomsky normal form if it generates exactly 2 non-terminals
	/// exclusive or one or zero terminal symbols
	public var isInChomskyNormalForm: Bool {
		if isFinal {
			return production.count == 1
		}
        return self.production.allSatisfy { symbol -> Bool in
			if case .nonTerminal(_) = symbol {
				return true
			} else {
				return false
			}
		} && self.production.count == 2
	}
	
	/// Sequence of terminals generated by this production
	public var generatedTerminals: [Terminal] {
		return production.compactMap{ symbol -> Terminal? in
			guard case .terminal(let terminal) = symbol  else {
				return nil
			}
			return terminal
		}
	}
	
	var terminalPrefix: [Terminal] {
		let prefix = production.prefix(while: { symbol -> Bool in
			if case .terminal(_) = symbol {
				return true
			} else {
				return false
			}
		})
		return prefix.compactMap { symbol -> Terminal? in
			guard case .terminal(let terminal) = symbol else {
				return nil
			}
			return terminal
		}
	}
	
	var terminalSuffix: [Terminal] {
		let suffix = production.reversed().prefix(while: { symbol -> Bool in
			if case .terminal(_) = symbol {
				return true
			} else {
				return false
			}
		}).reversed()
		
		return suffix.compactMap { symbol -> Terminal? in
			guard case .terminal(let terminal) = symbol else {
				return nil
			}
			return terminal
		}
	}
	
	var generatedNonTerminals: [NonTerminal] {
		return production.compactMap { symbol -> NonTerminal? in
			guard case .nonTerminal(let nonTerminal) = symbol else {
				return nil
			}
			return nonTerminal
		}
	}
	
	func generatesEmpty(in grammar: Grammar) -> Bool {
		let groupedProductions = Dictionary(grouping: grammar.productions, by: {$0.pattern})
		
		func generatesEmpty(_ nonTerminal: NonTerminal, path: Set<NonTerminal>) -> Bool {
			if path.contains(nonTerminal) {
				return false
			}
			
			let directProductions = groupedProductions[nonTerminal, default: []]
			return directProductions.contains { production -> Bool in
				if production.production.isEmpty {
					return true
				}
				return production.generatedNonTerminals.count == production.production.count
                    && production.generatedNonTerminals.allSatisfy { pattern -> Bool in
						generatesEmpty(pattern, path: path.union([nonTerminal]))
				}
			}
		}
		
        return self.production.allSatisfy { symbol -> Bool in
			switch symbol {
			case .terminal:
				return false
				
			case .nonTerminal(let nonTerminal):
				return generatesEmpty(nonTerminal, path: [])
			}
		}
	}
}

extension Production: Hashable {
	
	public static func ==(lhs: Production, rhs: Production) -> Bool {
		return lhs.pattern == rhs.pattern && lhs.production == rhs.production
	}
}

extension Production: CustomStringConvertible {
	public var description: String {
		return "\(pattern.name) --> \(production.map{$0.description}.joined(separator: " "))"
	}
}

extension Production: CustomDebugStringConvertible {
	public var debugDescription: String {
		return """
		production {
			pattern: \(self.pattern)
			produces: \(self.production.map{$0.description})
			chain: \(self.nonTerminalChain?.map{$0.description}.joined(separator: ", ") ?? "empty")
		}
		"""
	}
}

precedencegroup ProductionPrecedence {
	associativity: left
	lowerThan: AdditionPrecedence
}

infix operator --> : ProductionPrecedence

/// Generates a production from a given non-terminal and produced sequence of symbols
///
/// - Parameters:
///   - lhs: Non-terminal pattern
///   - rhs: Produced string of symbols
/// - Returns: Production with the given pattern and generated result
public func --> (lhs: NonTerminal, rhs: ProductionString) -> Production {
	return Production(pattern: lhs, production: rhs)
}

/// Generates a set of productions from a given non-terminal and produced result
///
/// - Parameters:
///   - lhs: Non-terminal pattern
///   - rhs: Collection of possible produced strings of symbols
/// - Returns: Productions with the given pattern and generated results
public func --> (lhs: NonTerminal, rhs: ProductionResult) -> [Production] {
	return rhs.elements.map { producedString in
		return Production(pattern: lhs, production: producedString)
	}
}

/// Generates a production from the given non-terminal to the given symbol
///
/// - Parameters:
///   - lhs: Non-terminal pattern
///   - rhs: Produced symbol
/// - Returns: Production with the given pattern generating the given symbol
public func --> (lhs: NonTerminal, rhs: Symbol) -> Production {
	return Production(pattern: lhs, production: [rhs])
}

